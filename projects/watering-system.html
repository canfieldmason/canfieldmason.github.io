<!DOCTYPE html>
<html>
<head>
  <title>Automated Plant Watering System</title>

  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      max-width: 900px;
      margin: 40px auto;
      line-height: 1.6;
      color: #222;
      padding: 0 20px;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
    }

    h2 {
      margin-top: 50px;
      color: #111;
    }

    p {
      margin: 15px 0;
    }

    img {
      display: block;
      margin: 25px auto 10px auto;
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
    }

    em {
      display: block;
      text-align: center;
      color: #555;
      font-size: 0.95em;
      margin-bottom: 30px;
    }

    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 50px 0;
    }

    .nav-link {
      display: inline-block;
      margin-bottom: 30px;
      color: #0066cc;
      text-decoration: none;
      font-size: 0.95em;
    }

    .nav-link:hover {
      text-decoration: underline;
    }

    .status {
      background-color: #f7f7f7;
      border-left: 4px solid #ddd;
      padding: 15px 20px;
      margin: 30px 0;
    }

    pre {
      background: #f4f4f4;
      padding: 15px;
      border: 1px solid #ddd;
      overflow-x: auto;
    }

    code {
      font-family: Consolas, monospace;
      font-size: 0.9em;
    }
  </style>
</head>

<body>

<div style="
  text-align:center;
  margin-bottom:30px;
  padding-bottom:10px;
  border-bottom:1px solid #ddd;
">
  <a href="/index.html" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">Home</a>
  <a href="/projects/index.html" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">Projects</a>
  <a href="/resume.pdf" target="_blank" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">Resume</a>
  <a href="https://www.linkedin.com/in/mason-canfield" target="_blank" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">LinkedIn</a>
</div>

<a href="/projects/index.html" class="nav-link">← Back to Projects</a>

<h1>Automated Plant Watering System</h1>

<p><em>Arduino-based embedded system for soil monitoring and autonomous pump control</em></p>

<p>
This project developed a fully autonomous embedded system capable of monitoring soil moisture and controlling water pumps without user intervention. The system integrates analog sensing, power electronics, and microcontroller logic to maintain plant health through automated feedback-based control, preventing both underwatering and surface runoff caused by rapid oversaturation.
</p>

<div class="status">
<strong>System Specifications:</strong>
<ul>
  <li>Microcontroller: Arduino (5V logic)</li>
  <li>Soil Moisture Sensor: ST0160 capacitive sensor (DigiKey 4411-ST0160-ND)</li>
  <li>Operating Voltage: 5V system power</li>
  <li>Actuators: 2x 5V DC water pumps (MOSFET-switched)</li>
  <li>Control Method: Timed pulse modulation</li>
  <li>Input Method: Pushbutton using Arduino internal pull-up resistor</li>
  <li>User Interface: Status LED and manual override button</li>
</ul>
</div>

<hr>

<h2>Tools & Technologies</h2>

<ul>
  <li>Arduino hardware and embedded C++ programming</li>
  <li>ST0160 capacitive soil moisture sensors</li>
  <li>MOSFET-based power switching circuits</li>
  <li>5V analog sensor integration</li>
  <li>Breadboard prototyping and rapid iteration</li>
  <li>Serial debugging and system testing</li>
</ul>

<hr>

<h2>Early Prototype Development</h2>

<p>
Initial testing focused on validating core functionality using a simplified breadboard configuration. This early prototype included an Arduino microcontroller, a single ST0160 capacitive soil moisture sensor, a MOSFET driver circuit, and an indicator LED. The objective was to confirm reliable sensor readings, pump control logic, and user feedback before expanding to a full multi-pump system.
</p>

<img src="../images/watering-system-prototype.JPG" alt="Early prototype with Arduino, sensor, and MOSFET">
<em>Initial breadboard prototype used to verify sensing and pump actuation logic.</em>

<p>
This configuration enabled rapid iteration of control strategies and allowed tuning of threshold values and timing behavior before permanent integration. Testing determined that a dryness threshold of approximately <strong>550</strong> on the Arduino’s 10-bit ADC scale (0–1023) provided reliable activation for the selected sensor.
</p>

<hr>

<h2>System Architecture</h2>

<p>
A block diagram of the system will be added to illustrate signal flow between the moisture sensors, Arduino controller, MOSFET driver circuits, and pumps. This diagram will be developed and refined alongside upcoming coursework in control systems.
</p>

<img src="../images/watering-system-diagram-placeholder.png" alt="System block diagram placeholder">
<em>Planned system block diagram showing sensors, controller, and pump drivers.</em>

<hr>

<h2>Final System Integration</h2>

<p>
The completed system expanded upon the prototype to include dual pumps, enclosure mounting, and a dedicated manual override function. All components were powered from a common 5V supply, simplifying wiring and allowing safe low-voltage operation.
</p>

<img src="../images/watering-system-final.jpg" alt="Completed watering system assembly">
<em>Fully integrated system with Arduino controller, sensors, and dual pumps.</em>

<p>
The final design supports both automatic moisture-based watering and a pushbutton-activated manual mode for on-demand operation. An LED indicator provides immediate visual feedback when the soil is adequately moist and no watering is required.
</p>

<hr>

<h2>Control Software</h2>

<p>
The system software was written in Arduino C++ and implements a pulsed pump strategy to prevent overwatering and allow soil absorption between cycles. Moisture levels are continuously monitored, and pumps are activated only when readings exceed the defined dryness threshold.
</p>

<p>
Testing showed that pump pulses of <strong>500 ms ON</strong> followed by <strong>3 seconds OFF</strong> cycles effectively hydrated soil without causing surface pooling or runoff. This approach reduced unnecessary water usage and minimized electrical and mechanical stress on the pumps.
</p>

<p>
Key features of the control logic include:
</p>

<ul>
  <li>Automatic pump pulsing when soil moisture falls below a set threshold</li>
  <li>Configurable ON/OFF timing to prevent continuous water flow</li>
  <li>Manual override mode using a physical pushbutton</li>
  <li>Status LED indicating adequate soil moisture</li>
  <li>Serial output for debugging and system feedback</li>
</ul>

<p>
The full embedded control program used in the project is shown below.
</p>

<pre><code class="language-cpp">
const int sensor1Pin = A0;
const int sensor2Pin = A2;
const int pump1Pin = 3;
const int pump2Pin = 5;
const int buttonPin = 2;
const int ledPin = 6;          // Added LED pin
const int dryThreshold = 550;  // Adjust based on sensor

// Pulsing settings
const unsigned long pumpOnTime = 500;     // 0.5s ON per pulse
const unsigned long pumpOffTime = 3000;   // 3s OFF between pulses
const unsigned long manualDuration = 10000; // 10s total manual mode runtime

// State variables
bool manualMode = false;
bool pumpRunning = false;
unsigned long lastPulseTime = 0;
unsigned long manualStartTime = 0;

void setup() {
  Serial.begin(9600);
  pinMode(pump1Pin, OUTPUT);
  pinMode(pump2Pin, OUTPUT);
  pinMode(ledPin, OUTPUT);      // Initialize LED pin
  pinMode(buttonPin, INPUT_PULLUP);
  digitalWrite(pump1Pin, LOW);
  digitalWrite(pump2Pin, LOW);
  digitalWrite(ledPin, LOW);    // Start with LED off
  Serial.println("System ready. Auto-pulsing active.");
}

void loop() {
  int sensor1Value = analogRead(sensor1Pin);
  
  // handle button press (with debounce)
  if (digitalRead(buttonPin) == LOW && !manualMode) {
    manualMode = true;
    manualStartTime = millis();
    Serial.println("MANUAL OVERRIDE: Pulsing mode activated");
    delay(200); // Debounce
  }

  // Automatic Pulsing Mode
  if (!manualMode) {
    if (sensor1Value > dryThreshold) {
      // Pulse the pump (ON/OFF cycle)
      if (millis() - lastPulseTime >= pumpOffTime && !pumpRunning) {
        digitalWrite(pump1Pin, HIGH);
        pumpRunning = true;
        lastPulseTime = millis();
        Serial.print("AUTO-PULSE: Pump ON (Dryness: ");
        Serial.print(sensor1Value);
        Serial.println(")");
      }
      else if (pumpRunning && millis() - lastPulseTime >= pumpOnTime) {
        digitalWrite(pump1Pin, LOW);
        pumpRunning = false;
        Serial.println("AUTO-PULSE: Pump OFF");
      }
    }
    else {
      digitalWrite(pump1Pin, LOW);
      pumpRunning = false;
    }
  }

  // Manual Pulsing Mode (with timeout)
  if (manualMode) {
    if (millis() - manualStartTime < manualDuration) {
      if (millis() - lastPulseTime >= pumpOffTime && !pumpRunning) {
        digitalWrite(pump1Pin, HIGH);
        digitalWrite(pump2Pin, HIGH);
        pumpRunning = true;
        lastPulseTime = millis();
        Serial.println("MANUAL-PULSE: Pumps ON");
      }
      else if (pumpRunning && millis() - lastPulseTime >= pumpOnTime) {
        digitalWrite(pump1Pin, LOW);
        digitalWrite(pump2Pin, LOW);
        pumpRunning = false;
        Serial.println("MANUAL-PULSE: Pumps OFF");
      }
    }
    else {
      manualMode = false;
      digitalWrite(pump1Pin, LOW);
      digitalWrite(pump2Pin, LOW);
      Serial.println("MANUAL OVERRIDE: Timeout - Returning to auto mode");
    }
  }

  // LED Control - ON when soil is wet AND pump isn't running
  if (sensor1Value <= dryThreshold && !pumpRunning && !manualMode) {
    digitalWrite(ledPin, HIGH);  // Turn LED on when conditions are met
  } else {
    digitalWrite(ledPin, LOW);   // Otherwise keep LED off
  }

  delay(50); // Small delay to reduce CPU load
}
</code></pre>

<hr>

<h2>Engineering Outcomes</h2>

<p>
The final system successfully demonstrated the benefits of automated, incremental watering compared to manual or continuous pump operation. During demonstration testing, soil that was allowed to dry excessively exhibited immediate surface runoff when watered. In contrast, soil maintained by the automated pulsing system absorbed water gradually with no runoff, confirming the effectiveness of the control strategy.
</p>

<p>
The project validated that low-cost capacitive sensors and simple timing-based control can maintain stable moisture conditions with minimal hardware complexity. The system operated reliably over extended testing periods and required no user interaction beyond initial setup.
</p>

<hr>

<h2>Future Improvements</h2>

<ul>
  <li>Add independent moisture sensing and control for each pump channel</li>
  <li>Add real-time clock scheduling for time-based watering modes</li>
  <li>Include a small LCD or wireless interface for user feedback</li>
  <li>Integrate current sensing to detect pump faults or dry-run conditions</li>
</ul>

<hr>

<h2>Lessons Learned</h2>

<p>
Developing this system provided valuable practical experience beyond basic classroom exercises. One major takeaway was the importance of designing control logic around real-world constraints. Early versions of the program ran the pump continuously, which quickly revealed issues with overwatering and unnecessary power consumption. Implementing a pulsed control strategy with timed ON and OFF cycles resulted in more reliable and efficient operation.
</p>

<p>
Another key lesson involved hardware and software interaction. Sensor readings were found to fluctuate based on soil conditions, wiring quality, and power supply noise. This required experimenting with threshold tuning, timing delays, and serial debugging to achieve stable performance. These adjustments reinforced the need to test embedded systems in realistic conditions rather than relying solely on ideal assumptions.
</p>

<p>
The project also highlighted the value of incremental prototyping. Starting with a minimal breadboard configuration allowed rapid debugging of the MOSFET driver circuit and moisture sensor interface before integrating additional pumps and features. This staged approach reduced troubleshooting time and made problems easier to isolate.
</p>

<p>
Finally, implementing a manual override button emphasized the importance of user interaction in embedded design. Building safeguards such as automatic timeouts and clear LED status indicators improved usability and prevented unintended continuous operation.
</p>

<p>
Overall, this project strengthened skills in embedded programming, electrical integration, and system-level thinking while demonstrating how iterative testing leads to practical and dependable engineering solutions.
</p>

</body>
</html>


