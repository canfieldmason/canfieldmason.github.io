<!DOCTYPE html>
<html>
<head>
  <title>Automated Plant Watering System</title>

  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      max-width: 900px;
      margin: 40px auto;
      line-height: 1.6;
      color: #222;
      padding: 0 20px;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
    }

    h2 {
      margin-top: 50px;
      color: #111;
    }

    p {
      margin: 15px 0;
    }

    img {
      display: block;
      margin: 25px auto 10px auto;
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
    }

    em {
      display: block;
      text-align: center;
      color: #555;
      font-size: 0.95em;
      margin-bottom: 30px;
    }

    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 50px 0;
    }

    .tools {
      font-style: italic;
      color: #444;
    }

    .nav-link {
      display: inline-block;
      margin-bottom: 30px;
      color: #0066cc;
      text-decoration: none;
      font-size: 0.95em;
    }

    .nav-link:hover {
      text-decoration: underline;
    }

    pre {
      background: #f4f4f4;
      padding: 15px;
      border: 1px solid #ddd;
      overflow-x: auto;
    }
  </style>
</head>

<body>
<div style="
  text-align:center;
  margin-bottom:30px;
  padding-bottom:10px;
  border-bottom:1px solid #ddd;
">
  <a href="/index.html" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">Home</a>
  <a href="/projects/index.html" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">Projects</a>
  <a href="/resume.pdf" target="_blank" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">Resume</a>
  <a href="https://www.linkedin.com/in/mason-canfield" target="_blank" style="margin:0 14px; color:#0066cc; text-decoration:none; font-weight:bold;">LinkedIn</a>
</div>

<a href="../projects/index.html" class="nav-link">‚Üê Back to Projects</a>

<h1>Automated Plant Watering System</h1>

<p><em>Arduino-based embedded system for soil monitoring and pump control</em></p>

<p>
This project involved the design and implementation of an embedded control system capable of automatically monitoring soil moisture levels and activating water pumps as needed. The system combines sensors, power electronics, and microcontroller logic to maintain plant health with minimal user intervention.
</p>

<p class="tools">
<strong>Tools:</strong> Arduino, MOSFET power switching, analog sensors, embedded C++, rapid prototyping
</p>

<hr>

<h2>Early Prototype Development</h2>

<p>
Initial testing focused on validating core functionality using a simplified breadboard configuration. This early prototype included an Arduino microcontroller, soil moisture sensor, MOSFET driver circuit, and indicator LED. The goal at this stage was to confirm sensor readings, pump control logic, and basic user feedback before expanding to a full system.
</p>

<img src="../images/watering-system-prototype.JPG" alt="Early prototype with Arduino, sensor, and MOSFET">
<em>Initial breadboard prototype used to verify sensing and pump actuation logic.</em>

<p>
This configuration allowed rapid iteration of control strategies and ensured that threshold values and timing behavior could be tuned before permanent integration.
</p>

<hr>

<h2>Final System Integration</h2>

<p>
The completed system expanded upon the prototype to include dual pumps, enclosure mounting, and a dedicated manual function. All components were wired into a compact and robust assembly suitable for real-world use.
</p>

<img src="../images/watering-system-final.jpg" alt="Completed watering system assembly">
<em>Fully integrated system with Arduino controller, sensors, and dual pumps.</em>

<p>
The final design supports both automatic moisture-based watering and a pushbutton-activated manual mode for on-demand operation. An LED indicator provides immediate visual feedback when the soil is adequately moist and no watering is required.
</p>

<hr>

<h2>Control Software</h2>

<p>
The system software was written in Arduino C++ and implements a pulsed pump strategy to prevent overwatering and allow soil absorption between cycles. Moisture levels are continuously monitored, and pumps are activated only when readings exceed a defined dryness threshold.
</p>

<p>
Key features of the control logic include:
</p>

<ul>
  <li>Automatic pump pulsing when soil moisture falls below a set threshold</li>
  <li>Configurable ON/OFF timing to prevent continuous water flow</li>
  <li>Manual override mode using a physical pushbutton</li>
  <li>Status LED indicating adequate soil moisture</li>
  <li>Serial output for debugging and system feedback</li>
</ul>

<p>
The full embedded control program used in the project is shown below.
</p>

<pre><code>
const int sensor1Pin = A0;
const int sensor2Pin = A2;
const int pump1Pin = 3;
const int pump2Pin = 5;
const int buttonPin = 2;
const int ledPin = 6;

const int dryThreshold = 550;

const unsigned long pumpOnTime = 500;
const unsigned long pumpOffTime = 3000;
const unsigned long manualDuration = 10000;

bool manualMode = false;
bool pumpRunning = false;
unsigned long lastPulseTime = 0;
unsigned long manualStartTime = 0;

void setup() {
  Serial.begin(9600);
  pinMode(pump1Pin, OUTPUT);
  pinMode(pump2Pin, OUTPUT);
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP);

  digitalWrite(pump1Pin, LOW);
  digitalWrite(pump2Pin, LOW);
  digitalWrite(ledPin, LOW);

  Serial.println("System ready. Auto-pulsing active.");
}

void loop() {
  int sensor1Value = analogRead(sensor1Pin);

  if (digitalRead(buttonPin) == LOW && !manualMode) {
    manualMode = true;
    manualStartTime = millis();
    Serial.println("MANUAL OVERRIDE: Pulsing mode activated");
    delay(200);
  }

  if (!manualMode) {
    if (sensor1Value > dryThreshold) {
      if (millis() - lastPulseTime >= pumpOffTime && !pumpRunning) {
        digitalWrite(pump1Pin, HIGH);
        pumpRunning = true;
        lastPulseTime = millis();
        Serial.println("AUTO-PULSE: Pump ON");
      }
      else if (pumpRunning && millis() - lastPulseTime >= pumpOnTime) {
        digitalWrite(pump1Pin, LOW);
        pumpRunning = false;
        Serial.println("AUTO-PULSE: Pump OFF");
      }
    }
    else {
      digitalWrite(pump1Pin, LOW);
      pumpRunning = false;
    }
  }

  if (manualMode) {
    if (millis() - manualStartTime < manualDuration) {
      if (millis() - lastPulseTime >= pumpOffTime && !pumpRunning) {
        digitalWrite(pump1Pin, HIGH);
        digitalWrite(pump2Pin, HIGH);
        pumpRunning = true;
        lastPulseTime = millis();
        Serial.println("MANUAL-PULSE: Pumps ON");
      }
      else if (pumpRunning && millis() - lastPulseTime >= pumpOnTime) {
        digitalWrite(pump1Pin, LOW);
        digitalWrite(pump2Pin, LOW);
        pumpRunning = false;
        Serial.println("MANUAL-PULSE: Pumps OFF");
      }
    }
    else {
      manualMode = false;
      digitalWrite(pump1Pin, LOW);
      digitalWrite(pump2Pin, LOW);
      Serial.println("MANUAL OVERRIDE: Timeout");
    }
  }

  if (sensor1Value <= dryThreshold && !pumpRunning && !manualMode) {
    digitalWrite(ledPin, HIGH);
  } else {
    digitalWrite(ledPin, LOW);
  }

  delay(50);
}
</code></pre>


<hr>

<h2>Engineering Outcomes</h2>

<p>
This project provided practical experience in embedded system design, including sensor integration, power electronics control, and real-time programming. The pulsed watering strategy demonstrated effective resource management while protecting components from excessive cycling.
</p>

<p>
The final system operates reliably without user intervention and illustrates a complete development process from concept, to prototype, to finished functional product.
</p>

<hr>

<h2>Lessons Learned</h2>

<p>
Developing this system provided valuable practical experience beyond basic classroom exercises. One major takeaway was the importance of designing control logic around real-world constraints. Early versions of the program ran the pump continuously, which quickly revealed issues with overwatering and unnecessary power consumption. Implementing a pulsed control strategy with timed ON and OFF cycles resulted in more reliable and efficient operation.
</p>

<p>
Another key lesson involved hardware and software interaction. Sensor readings were found to fluctuate based on soil conditions, wiring quality, and power supply noise. This required experimenting with threshold tuning, timing delays, and serial debugging to achieve stable performance. These adjustments reinforced the need to test embedded systems in realistic conditions rather than relying solely on ideal assumptions.
</p>

<p>
The project also highlighted the value of incremental prototyping. Starting with a minimal breadboard configuration allowed rapid debugging of the MOSFET driver circuit and moisture sensor interface before integrating additional pumps and features. This staged approach reduced troubleshooting time and made problems easier to isolate.
</p>

<p>
Finally, implementing a manual override button emphasized the importance of user interaction in embedded design. Building safeguards such as automatic timeouts and clear LED status indicators improved usability and prevented unintended continuous operation.
</p>

<p>
Overall, this project strengthened skills in embedded programming, electrical integration, and system-level thinking while demonstrating how iterative testing leads to practical and dependable engineering solutions.
</p>

</body>
</html>
